@page "/"
@using DoggyLife.Components
@using DoggyLife.Physics
@using DoggyLife.Rendering
@using DoggyLife.Rendering.Isometric
@using DoggyLife.Models
@using DoggyLife.Settings
@using SkiaSharp
@using SkiaSharp.Views.Blazor
@using System.Numerics
@inject IJSRuntime JSRuntime
@inject HttpClient Http

<div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;"
    @onkeydown="OnKeyPress" tabindex="0">
    @if (!_isPlaying)
    {
        <PixelButton OnClick="(async () => await PlayGame())">
            Play
        </PixelButton>
    }
    else
    {
        <div style="display: flex; flex-direction: column; align-items: center;">
            <PixelButton OnClick="ToggleGameMode">
                Mode: @_currentGameMode
            </PixelButton>

            <SKCanvasView Width="@_width" Height="@_height" EnableRenderLoop="true" IgnorePixelScaling="true"
                OnPaintSurface="OnGamePaint" />

            <div style="margin-top: 20px; text-align: center;">
                <p>Dog Animation Controls</p>
                <div style="margin-top: 10px;">
                    <button @onclick="() => SetDogState(DogAnimationState.FrontStanding)">Front Standing</button>
                    <button @onclick="() => SetDogState(DogAnimationState.LeftWalking)">Side Walking</button>
                    <button @onclick="() => SetDogState(DogAnimationState.BackStanding)">Back Standing</button>
                    <button @onclick="() => SetDogState(DogAnimationState.Laying)">Laying</button>
                </div>
                <div style="margin-top: 5px;">
                    <button @onclick="() => SetDogState(DogAnimationState.FrontWalking)">Front Walking</button>
                    <button @onclick="() => SetDogState(DogAnimationState.LeftStanding)">Side Standing</button>
                    <button @onclick="() => SetDogState(DogAnimationState.BackWalking)">Back Walking</button>
                </div>
            </div>
        </div>
    }
</div>

@code {
    private MusicTrack _musicTrack = MusicTrack.None;
    private Scene _environment = Scene.Garden;
    private VerletSystem _verletSystem;
    private bool _isPlaying = false;
    private int _width = 300;
    private int _height = 300;
    private float _deltaTime = 0.016f;

    private GameMode _currentGameMode = GameMode.Interaction;

    private float _hologramX = 0;
    private float _hologramY = 0;
    private float _hologramMoveSpeed = 0.1f;

    private WallCursor _wallCursor = new(WallSide.Left, 0, 0);

    private DogAnimation _dogAnimation = new DogAnimation();
    private float _dogX = 150;
    private float _dogY = 150;
    private float _dogScale = 0.5f;
    private float _dogSize = 25; // Size of the dog sprite in pixels

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        await LoadAssets();
    }

    private async Task LoadAssets()
    {
        try
        {
            await _dogAnimation.LoadSpritesheetAsync(Http, "images/dogs/dog1.png");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading assets: {ex.Message}");
        }
    }

    private void SetDogState(DogAnimationState state)
    {
        _dogAnimation.SetState(state);
    }

    private async Task PlayGame()
    {
        if (_isPlaying) return;

        SetupVerletSystem();
        await PlayMatchaGreen();
        _isPlaying = true;

        _hologramX = IsometricConfig.GridWidth / 2;
        _hologramY = IsometricConfig.GridLength / 2;
    }

    private void SetupVerletSystem()
    {
        _verletSystem = new VerletSystem(_width, _height);
    }

    private async Task PlayMatchaGreen()
    {
        if (_musicTrack != MusicTrack.None) return;

        await JSRuntime.InvokeVoidAsync("changeTrack", "Matcha Green Tea");
        _musicTrack = MusicTrack.MatchaGreenTea;
        StateHasChanged();
    }

    private void ToggleGameMode()
    {
        _currentGameMode = _currentGameMode switch
        {
            GameMode.Interaction => GameMode.FloorEditor,
            GameMode.FloorEditor => GameMode.WallEditor,
            GameMode.WallEditor => GameMode.Viewer,
            GameMode.Viewer => GameMode.Interaction,
            _ => GameMode.Interaction
        };

        if (_currentGameMode == GameMode.WallEditor)
            _wallCursor = new(WallSide.Left, 0, 0);

        StateHasChanged();
    }

    public void OnKeyPress(KeyboardEventArgs e)
    {
        var key = e.Key.ToLower();

        if (_currentGameMode == GameMode.FloorEditor)
        {
            switch (key)
            {
                case "arrowup":
                case "w":
                    if (_hologramY > 0)
                        _hologramY -= _hologramMoveSpeed;
                    break;
                case "arrowdown":
                case "s":
                    if (_hologramY < IsometricConfig.GridLength - 1)
                        _hologramY += _hologramMoveSpeed;
                    break;
                case "arrowleft":
                case "a":
                    if (_hologramX > 0)
                        _hologramX -= _hologramMoveSpeed;
                    break;
                case "arrowright":
                case "d":
                    if (_hologramX < IsometricConfig.GridWidth - 1)
                        _hologramX += _hologramMoveSpeed;
                    break;
            }
        }
        else if (_currentGameMode == GameMode.WallEditor)
        {
            switch (key)
            {
                case "arrowleft":
                case "a":
                    // For left wall, we need to invert the direction to match visual expectations
                    // So 'a' moves cursor to the left side of the left wall
                    _wallCursor.MoveHorizontal(_wallCursor.Side == WallSide.Left ? -1 : -1, _hologramMoveSpeed);
                    break;
                case "arrowright":
                case "d":
                    _wallCursor.MoveHorizontal(_wallCursor.Side == WallSide.Left ? 1 : 1, _hologramMoveSpeed);
                    break;
                case "arrowup":
                case "w":
                    _wallCursor.MoveVertical(1, _hologramMoveSpeed); // Move up (increase height)
                    break;
                case "arrowdown":
                case "s":
                    _wallCursor.MoveVertical(-1, _hologramMoveSpeed); // Move down (decrease height)
                    break;
                case "t": // Alternative key to toggle wall side
                    _wallCursor.ToggleWallSide();
                    break;
            }
        }
        else if (_currentGameMode == GameMode.Interaction)
        {
            switch (key)
            {
                case "arrowup":
                case "w":
                    _dogY -= 5;
                    _dogAnimation.SetState(DogAnimationState.BackWalking);
                    break;
                case "arrowdown":
                case "s":
                    _dogY += 5;
                    _dogAnimation.SetState(DogAnimationState.FrontWalking);
                    break;
                case "arrowleft":
                case "a":
                    _dogX -= 5;
                    _dogAnimation.SetState(DogAnimationState.LeftWalking);
                    break;
                case "arrowright":
                case "d":
                    _dogX += 5;
                    _dogAnimation.SetState(DogAnimationState.LeftWalking);
                    break;
                case " ":
                    _dogAnimation.SetState(DogAnimationState.Laying);
                    break;
            }
        }

        StateHasChanged();
    }

    private void OnGamePaint(SKPaintSurfaceEventArgs e)
    {
        var canvas = e.Surface.Canvas;
        canvas.Clear(SKColors.Black);

        IsometricRoomBuilder.DrawIsometricRoom(canvas, _width, _height);

        if (_currentGameMode == GameMode.FloorEditor)
            DrawFloorHologram(canvas);

        if (_currentGameMode == GameMode.WallEditor)
            DrawWallHologram(canvas);

        // Update and draw dog animations
        _dogAnimation.Update(_deltaTime);
        _dogAnimation.Draw(canvas, _dogX, _dogY, _dogScale); // Scale up for better visibility

        _verletSystem.Update(_deltaTime);
        _verletSystem.Draw(canvas);

        canvas.DrawRect(new SKRect(0, 0, _width, _height), new SKPaint
        {
            Color = SKColors.White,
            Style = SKPaintStyle.Stroke,
            StrokeWidth = 2
        });

        // Add text to show current dog animation state
        var textPaint = new SKPaint
        {
            Color = SKColors.White,
            IsAntialias = true
        };
        canvas.DrawText($"Current animation: {_dogAnimation._currentState}", 10, 20, textPaint);
    }

    private void DrawFloorHologram(SKCanvas canvas)
    {
        float isoX = IsometricConfig.IsoX;
        float isoY = IsometricConfig.IsoY;
        float offsetX = IsometricConfig.GetOffsetX(_width);
        float offsetY = IsometricConfig.GetOffsetY(_height);
        var x = _hologramX;
        var y = _hologramY;

        float x1 = (x - y) * IsometricConfig.GridSize * isoX + offsetX;
        float y1 = (x + y) * IsometricConfig.GridSize * isoY + offsetY;
        float x2 = ((x + 1) - y) * IsometricConfig.GridSize * isoX + offsetX;
        float y2 = ((x + 1) + y) * IsometricConfig.GridSize * isoY + offsetY;
        float x3 = ((x + 1) - (y + 1)) * IsometricConfig.GridSize * isoX + offsetX;
        float y3 = ((x + 1) + (y + 1)) * IsometricConfig.GridSize * isoY + offsetY;
        float x4 = (x - (y + 1)) * IsometricConfig.GridSize * isoX + offsetX;
        float y4 = (x + (y + 1)) * IsometricConfig.GridSize * isoY + offsetY;

        var path = new SKPath();
        path.MoveTo(x1, y1);
        path.LineTo(x2, y2);
        path.LineTo(x3, y3);
        path.LineTo(x4, y4);
        path.Close();

        var fill = new SKPaint
        {
            IsAntialias = true,
            Color = new SKColor(0, 255, 0, 128),
            Style = SKPaintStyle.Fill
        };
        var stroke = new SKPaint
        {
            IsAntialias = true,
            Color = new SKColor(0, 255, 0, 255),
            Style = SKPaintStyle.Stroke,
            StrokeWidth = 2
        };

        canvas.DrawPath(path, fill);
        canvas.DrawPath(path, stroke);
    }

    private void DrawWallHologram(SKCanvas canvas)
    {
        float isoX = IsometricConfig.IsoX;
        float isoY = IsometricConfig.IsoY;
        float offsetX = IsometricConfig.GetOffsetX(_width);
        float offsetY = IsometricConfig.GetOffsetY(_height);

        float x1, y1, x2, y2;

        // Calculate base points for wall segment based on side
        if (_wallCursor.Side == WallSide.Left)
        {
            // Left wall logic - matches DrawLeftWall in IsometricWallBuilder
            float y = _wallCursor.Position;
            // Bottom-left corner of the floor tile
            x1 = (0 - y) * IsometricConfig.GridSize * isoX + offsetX;
            y1 = (0 + y) * IsometricConfig.GridSize * isoY + offsetY;
            // Bottom-right corner of the floor tile
            x2 = (0 - (y + 1)) * IsometricConfig.GridSize * isoX + offsetX;
            y2 = (0 + (y + 1)) * IsometricConfig.GridSize * isoY + offsetY;
        }
        else // Right wall
        {
            // Right wall logic - matches DrawRightWall in IsometricWallBuilder
            float x = _wallCursor.Position;
            // Bottom-left corner of the floor tile
            x1 = (x - 0) * IsometricConfig.GridSize * isoX + offsetX;
            y1 = (x + 0) * IsometricConfig.GridSize * isoY + offsetY;
            // Bottom-right corner of the floor tile
            x2 = ((x + 1) - 0) * IsometricConfig.GridSize * isoX + offsetX;
            y2 = ((x + 1) + 0) * IsometricConfig.GridSize * isoY + offsetY;
        }

        // Calculate the height offset in pixels (consistent with IsometricWallBuilder)
        float baseWallHeight = _wallCursor.Height * IsometricConfig.GridSize * isoY;
        float hologramHeight = IsometricConfig.GridSize * isoY * 0.3f;

        // Draw visual guides to show where the wall will connect to the floor
        var guidePaint = new SKPaint
        {
            IsAntialias = true,
            Color = new SKColor(255, 255, 0, 150),
            Style = SKPaintStyle.Stroke,
            StrokeWidth = 1,
            PathEffect = SKPathEffect.CreateDash(new float[] { 4, 4 }, 0)
        };

        // Draw guides from floor to wall base
        canvas.DrawLine(x1, y1, x1, y1 - baseWallHeight, guidePaint);
        canvas.DrawLine(x2, y2, x2, y2 - baseWallHeight, guidePaint);

        // Calculate points for the wall hologram
        var path = new SKPath();

        // Bottom edge at current height
        path.MoveTo(x1, y1 - baseWallHeight);
        path.LineTo(x2, y2 - baseWallHeight);

        // Top edge at hologram height above current height
        float x3 = x2;
        float y3 = y2 - baseWallHeight - hologramHeight;
        float x4 = x1;
        float y4 = y1 - baseWallHeight - hologramHeight;

        path.LineTo(x3, y3);
        path.LineTo(x4, y4);
        path.Close();

        // Draw the hologram
        var fill = new SKPaint
        {
            IsAntialias = true,
            Color = new SKColor(0, 255, 0, 128),
            Style = SKPaintStyle.Fill
        };
        var stroke = new SKPaint
        {
            IsAntialias = true,
            Color = new SKColor(0, 255, 0, 255),
            Style = SKPaintStyle.Stroke,
            StrokeWidth = 2
        };

        canvas.DrawPath(path, fill);
        canvas.DrawPath(path, stroke);

        // Draw connection points
        var pointPaint = new SKPaint
        {
            IsAntialias = true,
            Color = SKColors.Yellow,
            Style = SKPaintStyle.Fill
        };

        // Draw indicators at the connection points
        canvas.DrawCircle(x1, y1 - baseWallHeight, 3, pointPaint);
        canvas.DrawCircle(x2, y2 - baseWallHeight, 3, pointPaint);

        // Add grid indicator to show exact wall position
        var gridPaint = new SKPaint
        {
            IsAntialias = true,
            Color = SKColors.Red,
            Style = SKPaintStyle.Fill
        };

        // If right wall, draw position indicator on the floor
        if (_wallCursor.Side == WallSide.Right)
        {
            float x = _wallCursor.Position;
            float floorX = (x - 0) * IsometricConfig.GridSize * isoX + offsetX;
            float floorY = (x + 0) * IsometricConfig.GridSize * isoY + offsetY;
            canvas.DrawCircle(floorX, floorY, 4, gridPaint);
        }
        else // Left wall
        {
            float y = _wallCursor.Position;
            float floorX = (0 - y) * IsometricConfig.GridSize * isoX + offsetX;
            float floorY = (0 + y) * IsometricConfig.GridSize * isoY + offsetY;
            canvas.DrawCircle(floorX, floorY, 4, gridPaint);
        }
    }
}