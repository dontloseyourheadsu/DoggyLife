@page "/"
@using DoggyLife.Components
@using DoggyLife.Physics
@using DoggyLife.Rendering.Isometric
@using DoggyLife.Models
@using DoggyLife.Settings
@using SkiaSharp
@using SkiaSharp.Views.Blazor
@using System.Numerics
@inject IJSRuntime JSRuntime

<div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;"
    @onkeydown="OnKeyPress">
    @if (!_isPlaying)
    {
        <PixelButton OnClick="(async () => await PlayGame())">
            Play
        </PixelButton>
    }
    else
    {
        <div style="display: flex; flex-direction: column; align-items: center;">
            <PixelButton OnClick="ToggleGameMode">
                Mode: @_currentGameMode
            </PixelButton>

            <SKCanvasView Width="@_width" Height="@_height" EnableRenderLoop="true" IgnorePixelScaling="true"
                OnPaintSurface="OnGamePaint" />
        </div>
    }
</div>

@code {
    private MusicTrack _musicTrack = MusicTrack.None;
    private Scene _environment = Scene.Garden;
    private VerletSystem _verletSystem;
    private bool _isPlaying = false;
    private int _width = 300;
    private int _height = 300;
    private float _deltaTime = 0.016f;

    private GameMode _currentGameMode = GameMode.Interaction;

    private float _hologramX = 0;
    private float _hologramY = 0;
    private float _hologramMoveSpeed = 0.1f;

    private WallCursor _wallCursor = new(WallSide.Left, 0, 0);

    private async Task PlayGame()
    {
        if (_isPlaying) return;

        SetupVerletSystem();
        await PlayMatchaGreen();
        _isPlaying = true;

        _hologramX = IsometricConfig.GridWidth / 2;
        _hologramY = IsometricConfig.GridLength / 2;
    }

    private void SetupVerletSystem()
    {
        _verletSystem = new VerletSystem(_width, _height);
    }

    private async Task PlayMatchaGreen()
    {
        if (_musicTrack != MusicTrack.None) return;

        await JSRuntime.InvokeVoidAsync("changeTrack", "Matcha Green Tea");
        _musicTrack = MusicTrack.MatchaGreenTea;
        StateHasChanged();
    }

    private void ToggleGameMode()
    {
        _currentGameMode = _currentGameMode switch
        {
            GameMode.Interaction => GameMode.FloorEditor,
            GameMode.FloorEditor => GameMode.WallEditor,
            GameMode.WallEditor => GameMode.Viewer,
            GameMode.Viewer => GameMode.Interaction,
            _ => GameMode.Interaction
        };

        if (_currentGameMode == GameMode.WallEditor)
            _wallCursor = new(WallSide.Left, 0, 0);

        StateHasChanged();
    }

    public void OnKeyPress(KeyboardEventArgs e)
    {
        var key = e.Key.ToLower();

        if (_currentGameMode == GameMode.FloorEditor)
        {
            switch (key)
            {
                case "arrowup":
                case "w":
                    if (_hologramY > 0)
                        _hologramY -= _hologramMoveSpeed;
                    break;
                case "arrowdown":
                case "s":
                    if (_hologramY < IsometricConfig.GridLength - 1)
                        _hologramY += _hologramMoveSpeed;
                    break;
                case "arrowleft":
                case "a":
                    if (_hologramX > 0)
                        _hologramX -= _hologramMoveSpeed;
                    break;
                case "arrowright":
                case "d":
                    if (_hologramX < IsometricConfig.GridWidth - 1)
                        _hologramX += _hologramMoveSpeed;
                    break;
            }
        }
        else if (_currentGameMode == GameMode.WallEditor)
        {
            switch (key)
            {
                case "arrowleft":
                case "a":
                    if (_wallCursor.Side == WallSide.Left)
                        _wallCursor.MoveHorizontal(-1, _hologramMoveSpeed); // Move left along wall
                    break;
                case "arrowright":
                case "d":
                    if (_wallCursor.Side == WallSide.Left)
                        _wallCursor.MoveHorizontal(+1, _hologramMoveSpeed); // Move right along wall
                    break;
                case "arrowup":
                case "w":
                    _wallCursor.MoveVertical(+1, _hologramMoveSpeed); // Move up (increase height)
                    break;
                case "arrowdown":
                case "s":
                    _wallCursor.MoveVertical(-1, _hologramMoveSpeed); // Move down (decrease height)
                    break;
            }
        }

        StateHasChanged();
    }

    private void OnGamePaint(SKPaintSurfaceEventArgs e)
    {
        var canvas = e.Surface.Canvas;
        canvas.Clear(SKColors.Black);

        IsometricRoomBuilder.DrawIsometricRoom(canvas, _width, _height);

        if (_currentGameMode == GameMode.FloorEditor)
            DrawFloorHologram(canvas);

        if (_currentGameMode == GameMode.WallEditor)
            DrawWallHologram(canvas);

        _verletSystem.Update(_deltaTime);
        _verletSystem.Draw(canvas);

        canvas.DrawRect(new SKRect(0, 0, _width, _height), new SKPaint
        {
            Color = SKColors.White,
            Style = SKPaintStyle.Stroke,
            StrokeWidth = 2
        });
    }

    private void DrawFloorHologram(SKCanvas canvas)
    {
        float isoX = IsometricConfig.IsoX;
        float isoY = IsometricConfig.IsoY;
        float offsetX = IsometricConfig.GetOffsetX(_width);
        float offsetY = IsometricConfig.GetOffsetY(_height);
        var x = _hologramX;
        var y = _hologramY;

        float x1 = (x - y) * IsometricConfig.GridSize * isoX + offsetX;
        float y1 = (x + y) * IsometricConfig.GridSize * isoY + offsetY;
        float x2 = ((x + 1) - y) * IsometricConfig.GridSize * isoX + offsetX;
        float y2 = ((x + 1) + y) * IsometricConfig.GridSize * isoY + offsetY;
        float x3 = ((x + 1) - (y + 1)) * IsometricConfig.GridSize * isoX + offsetX;
        float y3 = ((x + 1) + (y + 1)) * IsometricConfig.GridSize * isoY + offsetY;
        float x4 = (x - (y + 1)) * IsometricConfig.GridSize * isoX + offsetX;
        float y4 = (x + (y + 1)) * IsometricConfig.GridSize * isoY + offsetY;

        var path = new SKPath();
        path.MoveTo(x1, y1);
        path.LineTo(x2, y2);
        path.LineTo(x3, y3);
        path.LineTo(x4, y4);
        path.Close();

        var fill = new SKPaint
        {
            IsAntialias = true,
            Color = new SKColor(0, 255, 0, 128),
            Style = SKPaintStyle.Fill
        };
        var stroke = new SKPaint
        {
            IsAntialias = true,
            Color = new SKColor(0, 255, 0, 255),
            Style = SKPaintStyle.Stroke,
            StrokeWidth = 2
        };

        canvas.DrawPath(path, fill);
        canvas.DrawPath(path, stroke);
    }

    private void DrawWallHologram(SKCanvas canvas)
    {
        float isoX = IsometricConfig.IsoX;
        float isoY = IsometricConfig.IsoY;
        float offsetX = IsometricConfig.GetOffsetX(_width);
        float offsetY = IsometricConfig.GetOffsetY(_height);

        float x1, y1, x2, y2;

        if (_wallCursor.Side == WallSide.Left)
        {
            float y = _wallCursor.Position;
            // Bottom edge of wall segment
            x1 = (0 - y) * IsometricConfig.GridSize * isoX + offsetX;
            y1 = (0 + y) * IsometricConfig.GridSize * isoY + offsetY;
            x2 = (0 - (y + 1)) * IsometricConfig.GridSize * isoX + offsetX;
            y2 = (0 + (y + 1)) * IsometricConfig.GridSize * isoY + offsetY;
        }
        else
        {
            // Right wall logic will be added later
            float x = _wallCursor.Position;
            x1 = (x - 0) * IsometricConfig.GridSize * isoX + offsetX;
            y1 = (x + 0) * IsometricConfig.GridSize * isoY + offsetY;
            x2 = ((x + 1) - 0) * IsometricConfig.GridSize * isoX + offsetX;
            y2 = ((x + 1) + 0) * IsometricConfig.GridSize * isoY + offsetY;
        }

        // Calculate the height offset from the floor
        float baseWallHeight = _wallCursor.Height * IsometricConfig.GridSize * isoY;
        float hologramHeight = IsometricConfig.GridSize * isoY * 0.3f; // Make hologram a bit taller

        // Top edge of hologram (going UP from the base height)
        float x3 = x2;
        float y3 = y2 - baseWallHeight - hologramHeight; // Subtract to go UP
        float x4 = x1;
        float y4 = y1 - baseWallHeight - hologramHeight; // Subtract to go UP

        var path = new SKPath();
        // Start from bottom edge at the height level
        path.MoveTo(x1, y1 - baseWallHeight);
        path.LineTo(x2, y2 - baseWallHeight);
        path.LineTo(x3, y3); // Top edge
        path.LineTo(x4, y4); // Top edge
        path.Close();

        var fill = new SKPaint
        {
            IsAntialias = true,
            Color = new SKColor(0, 255, 0, 128),
            Style = SKPaintStyle.Fill
        };
        var stroke = new SKPaint
        {
            IsAntialias = true,
            Color = new SKColor(0, 255, 0, 255),
            Style = SKPaintStyle.Stroke,
            StrokeWidth = 2
        };

        canvas.DrawPath(path, fill);
        canvas.DrawPath(path, stroke);

        // Debug: Draw a small circle at the cursor position for reference
        var debugPaint = new SKPaint
        {
            IsAntialias = true,
            Color = SKColors.Red,
            Style = SKPaintStyle.Fill
        };
        canvas.DrawCircle(x1, y1 - baseWallHeight, 3, debugPaint);
    }
}
